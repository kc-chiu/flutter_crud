import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

import 'models.dart';

class SqfliteTodosRepository implements TodosRepository {
  SqfliteTodosRepository() {
    futureDb = init();
  }

  late Future<Database> futureDb;

  Future<Database> init() async {
    return await openDatabase(
      // Set the path to the database. Note: Using the `join` function from the
      // `path` package is best practice to ensure the path is correctly
      // constructed for each platform.
      join(await getDatabasesPath(), 'todo_database.db'),
      // When the database is first created, create a table to store todos.
      onCreate: (db, version) {
        // Run the CREATE TABLE statement on the database.
        return db.execute(
          'CREATE TABLE todos('
          'id INTEGER PRIMARY KEY, '
          'title TEXT, '
          'isCompleted INTEGER, '
          'userId INTEGER)',
        );
      },
      // Set the version. This executes the onCreate function and provides a
      // path to perform database upgrades and downgrades.
      version: 1,
    );
  }

  /// Handles the difference in data representation between model and database.
  Map<String, dynamic> _mapFrom(Todo todo) {
    return {
      'id': int.parse(todo.id),
      'title': todo.title,
      'isCompleted': todo.isCompleted ? 1 : 0,
    };
  }

  /// Handles the difference in data representation between model and database.
  Todo _todoFrom(Map<String, dynamic> map) {
    return Todo(
      map['id'].toString(),
      map['title'],
      map['isCompleted'] == 1 ? true : false,
    );
  }

  @override
  Future<List<Todo>> readAllTodos(int userId) async {
    // Ensures initialized.
    final db = await futureDb;

    final todos = <Todo>[];
    try {
      final List<Map<String, dynamic>> maps = await db.query(
        'todos',
        where: 'userId = ?',
        whereArgs: [userId],
      );
      for (final map in maps) {
        todos.add(_todoFrom(map));
      }
    } on Exception catch (e) {
      throw Exception('Failed to read data: $e');
    }
    return todos;
  }

  @override
  Future<Todo> create(Todo todo, int userId) async {
    // Ensures initialized.
    final db = await futureDb;

    // New [Todo.id] is generated by database.
    try {
      final id = await db.insert(
        'todos',
        {
          'title': todo.title,
          'isCompleted': todo.isCompleted ? 1 : 0,
          'userId': userId,
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
      todo.id = id.toString();
    } on Exception catch (e) {
      throw Exception('Failed to create Todo: $e');
    }
    return todo;
  }

  @override
  Future<void> update(Todo todo) async {
    // Ensures initialized.
    final db = await futureDb;

    try {
      await db.update(
        'todos',
        _mapFrom(todo),
        where: 'id = ?',
        whereArgs: [int.parse(todo.id)],
      );
    } on Exception catch (e) {
      throw Exception('Failed to update Todo: $e');
    }
  }

  @override
  Future<void> delete(Todo todo) async {
    // Ensures initialized.
    final db = await futureDb;

    try {
      db.delete(
        'todos',
        where: 'id = ?',
        whereArgs: [int.parse(todo.id)],
      );
    } on Exception catch (e) {
      throw Exception('Failed to delete Todo: $e');
    }
  }
}
